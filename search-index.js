var N=null,E="",T="t",U="u",searchIndex={};
var R=["zerocaf::backend::u64","fieldelement","choice","scalar","minus_one","is_even","from_bytes","to_bytes","two_pow_k","Given a `k`: u64, compute `2^k` giving the resulting…","constants","Holds the value of the Curve basepoint, which has been…","zerocaf","edwardspoint","compressededwardsy","This function tries to build a Point over the Sonny Curve…","new_from_y_coord","projectivepoint","new_random_point","FieldElement","as_bytes","decompress","option","ristrettopoint","compress","compressedristretto","Output","zerocaf::traits","zerocaf::backend::u64::field","zerocaf::backend::u64::scalar","to_owned","clone_into","try_from","try_into","borrow_mut","zerocaf::edwards","result","type_id","initialize","borrow","typeid","zerocaf::montgomery","zerocaf::ristretto","identity","is_valid","Verifies if the curve equation (in projective twisted…","sqrt_ratio_i","Performs the conversion.","affinepoint","ordering","partial_cmp","default","montgomerypoint","Gives back the Identity point for the Extended Edwards…","ristretto255scalar","formatter","Compute `a + b (mod l)`.","Scalar multiplication: compute `Scalar * self`. This…","Scalar multiplication: compute `self * Scalar`. This…","index_mut","CompressedEdwardsY","EdwardsPoint","ProjectivePoint","AffinePoint","MontgomeryPoint","CompressedRistretto","RistrettoPoint","SqrtRatioI","Identity","ValidityCheck"];

searchIndex["zerocaf"]={"doc":"            ","i":[[0,"backend",R[12],"This contains the different backend implementations: `u64`…",N,N],[0,"u64","zerocaf::backend","The u64 backend contains the implementation of all of the…",N,N],[0,R[10],R[0],"This module contains backend-specific constant values as…",N,N],[7,"EDWARDS_A","zerocaf::backend::u64::constants","Edwards `a` variable value = `-1 (mod l)` equals:…",N,N],[7,"EDWARDS_D",E,"Edwards `d` variable value = `-126296/126297 (mod l)`…",N,N],[7,"INV_SQRT_A",E,"`(+)1/SQRT(a) (mod l)` equals:…",N,N],[7,"MINUS_SQRT_A",E,"`(-)SQRT(a) (mod l)` equals:…",N,N],[17,"L",E,"`L` is the order of base point for Sonny, in this case it…",N,N],[17,"LFACTOR",E,"Scalar-LFACTOR is the value that satisfies the equation:…",N,N],[17,"RR",E,"Montgomery modulus defined for Scalar arithmetics, `R^2 =…",N,N],[17,"FIELD_L",E,"`FIELD_L` is the order of the Prime field for Sonny, n…",N,N],[17,"RR_FIELD",E,"Montgomery modulus defined for FieldElement arithmetics,…",N,N],[17,"LFACTOR_FIELD",E,"FieldElement-LFACTOR is the value that satisfies the…",N,N],[17,"INV_RR",E,"Montgomery modulus defined for FieldElements on…",N,N],[17,"SQRT_MINUS_ONE",E,"Holds the value of one of both `sqrt(-1 (mod p)) values.…",N,N],[17,"INV_SQRT_A_MINUS_D",E,"`INV_SQRT_A_MINUS_D =…",N,N],[17,"SQRT_AD_MINUS_ONE",E,"`SQRT_AD_MINUS_ONE = `.",N,N],[17,"BASEPOINT",E,R[11],N,N],[17,"RISTRETTO_BASEPOINT",E,"Ristretto Basepoint.",N,N],[0,"field",R[0],"Field arithmetic modulo `2^252 +…",N,N],[3,R[19],R[28],"A `FieldElement` represents an element of the field which…",N,N],[12,"0",E,E,0,N],[11,"zero",E,"Construct zero.",0,[[],[R[1]]]],[11,"one",E,"Construct one.",0,[[],[R[1]]]],[11,R[4],E,"Construct -1 (mod l).",0,[[],[R[1]]]],[11,R[5],E,"Evaluate if a `FieldElement` is even or not.",0,[[],["bool"]]],[11,"is_positive",E,"Checks if a ´FieldElement` is considered negative…",0,[[["self"]],[R[2]]]],[11,R[6],E,"Load a `FieldElement` from the low 253b bits of a 256-bit…",0,[[],[R[1]]]],[11,R[7],E,"Serialize this `FieldElement` to a 32-byte array. The…",0,[[]]],[11,R[8],E,R[9],0,[[["u64"]],[R[1]]]],[11,"legendre_symbol",E,"Given a FieldElement, this function evaluates if it is a…",0,[[["self"]],[R[2]]]],[11,"inverse",E,"Compute `a^-1 (mod l)` using the the Savas & Koç modular…",0,[[["self"]],[R[1]]]],[0,R[3],R[0],"Arithmetic mod `2^249 +…",N,N],[3,"Scalar",R[29],"The `Scalar` struct represents an Scalar over the modulo…",N,N],[12,"0",E,E,1,N],[11,"zero",E,"Return a Scalar with value = `0`.",1,[[],[R[3]]]],[11,"one",E,"Return a Scalar with value = `1`.",1,[[],[R[3]]]],[11,R[4],E,"Return a Scalar with value = `-1 (mod l)`.",1,[[],[R[3]]]],[11,R[5],E,"Evaluate if a `Scalar` is even or not.",1,[[],["bool"]]],[11,R[6],E,"Unpack a 32 byte / 256 bit Scalar into 5 52-bit limbs.",1,[[],[R[3]]]],[11,"from_bytes_wide",E,"Reduce a 64 byte / 512 bit scalar mod l",1,[[],[R[3]]]],[11,R[7],E,"Pack the limbs of this `Scalar` into 32 bytes",1,[[["self"]]]],[11,R[8],E,R[9],1,[[["u64"]],[R[3]]]],[0,R[10],R[12],"Contains the curve-constants needed by different algorithm…",N,N],[17,"BASEPOINT_COMPRESSED","zerocaf::constants",R[11],N,N],[17,"RISTRETTO_BASEPOINT_COMPRESSED",E,"Ristretto Basepoint on compressed format.",N,N],[0,"edwards",R[12],"Edwards Point operations and their implementations are…",N,N],[3,R[60],R[35],"The first 255 bits of a `CompressedEdwardsY` represent the…",N,N],[12,"0",E,E,2,N],[3,R[61],E,"An `EdwardsPoint` represents a point on the Sonny Curve…",N,N],[12,"X",E,E,3,N],[12,"Y",E,E,3,N],[12,"Z",E,E,3,N],[12,"T",E,E,3,N],[3,R[62],E,"A `ProjectivePoint` represents a point on the Sonny Curve…",N,N],[12,"X",E,E,4,N],[12,"Y",E,E,4,N],[12,"Z",E,E,4,N],[3,R[63],E,"An `AffinePoint` represents a point on the Sonny Curve…",N,N],[12,"X",E,E,5,N],[12,"Y",E,E,5,N],[5,"double_and_add",E,"Implementation of the standard algorithm of…",N,[[[T],[R[3]]],[T]]],[5,"mul_by_cofactor",E,"Multiply by the cofactor: return (8 P).",N,[[[T]],[T]]],[5,"mul_by_pow_2",E,"Compute ([2^k] * P (mod l)).",N,[[[T],["u64"]],[T]]],[11,"from_slice",E,"Construct a `CompressedEdwardsY` from a slice of bytes.",2,[[],[R[14]]]],[11,R[7],E,"Return the `CompressedEdwardsY` as an array of bytes (it's…",2,[[["self"]]]],[11,R[21],E,"Attempt to decompress to an `EdwardsPoint`.",2,[[["self"]],[[R[13]],[R[22],[R[13]]]]]],[11,"to_montgomery",E,"Convert this `EdwardsPoint` on the Edwards model to the…",3,[[["self"]],[R[52]]]],[11,"coset4",E,"Prints the 4Coset where the input `EdwardsPoint` lives in.",3,[[["self"]]]],[11,R[24],E,"Compress this point to `CompressedEdwardsY` format.",3,[[["self"]],[R[14]]]],[11,R[16],E,R[15],3,[[[R[2]],[R[1]]],[[R[13]],[R[22],[R[13]]]]]],[11,R[18],E,R[15],3,[[[T]],[R[13]]]],[11,R[16],E,R[15],4,[[[R[2]],[R[1]]],[[R[17]],[R[22],[R[17]]]]]],[11,R[18],E,R[15],4,[[[T]],[R[17]]]],[0,"field",R[12],"A `FieldElement` represents an element of the finite field…",N,N],[6,R[19],"zerocaf::field","A `FieldElement` represents an element of the field `2^252…",N,N],[11,"random",E,"Generate a valid FieldElement choosen uniformly using…",6,[[[T]],[R[1]]]],[0,"montgomery",R[12],"Implementation that provides support for Montgomery Points…",N,N],[3,R[64],R[41],"Holds the u-coordinate of a point on the Montgomery form…",N,N],[12,"0",E,E,7,N],[11,R[20],E,"View this `MontgomeryPoint` as an array of bytes.",7,[[["self"]]]],[11,R[7],E,"Convert this `MontgomeryPoint` to an array of bytes.",7,[[["self"]]]],[11,"to_edwards",E,"Attempt to convert to an `EdwardsPoint`, using the…",7,[[["self"],["u8"]],[[R[13]],[R[22],[R[13]]]]]],[0,"ristretto",R[12],"Implementation of the Ristretto Protocol over the…",N,N],[3,R[65],R[42],"Ristretto Point expressed in wire format. Since the…",N,N],[12,"0",E,E,8,N],[3,R[66],E,E,N,N],[11,R[20],E,"Get the bytes of the `CompressedRistretto` point.",8,[[["self"]]]],[11,"copy_from_slice",E,E,8,[[],[R[25]]]],[11,R[21],E,"Attempt to decompress a `CompressedRistretto` point. This…",8,[[["self"]],[[R[22],[R[23]]],[R[23]]]]],[11,R[24],E,"Encode a Ristretto point represented by the point…",9,[[["self"]],[R[25]]]],[11,"from_uniform_bytes",E,"Construct a `RistrettoPoint` from 64 bytes of data.",9,[[],[R[23]]]],[11,R[18],E,"Generate a random `RistrettoPoint` from a 64-byte array…",9,[[[T]],[R[23]]]],[0,R[3],R[12],"A `Scalar` represents an element of the finite field…",N,N],[6,"Scalar","zerocaf::scalar","A `Scalar` represents an element of the field generated by…",N,N],[6,"Ristretto255Scalar",E,"This is a type alias for the Scalar type in the…",N,N],[11,"random",E,"Generate a valid Scalar choosen uniformly using user-…",10,[[[T]],[R[3]]]],[0,"traits",R[12],"Module for Public Trait implementations.",N,N],[0,"ops",R[27],E,N,N],[8,"Square","zerocaf::traits::ops","Trait that represents the `^2` operation for any kind of…",N,N],[16,R[26],E,E,11,N],[10,"square",E,"Returns the square of the input: `x^2`.",11,[[]]],[8,"Double",E,"Trait that represents the Point doubling operation for any…",N,N],[16,R[26],E,E,12,N],[10,"double",E,"Performs the point-doubling operation over the coordinates…",12,[[]]],[8,"Half",E,"Trait that represents the `/2` operation for any kind of…",N,N],[16,R[26],E,E,13,N],[10,"half",E,"Returns the half of the input: `x/2`.",13,[[]]],[8,"Pow",E,"Trait that represents the modular exponentiation…",N,N],[16,R[26],E,E,14,N],[10,"pow",E,"Returns  `a^b (mod l)`.",14,[[[T]]]],[8,"ModSqrt",E,E,N,N],[16,R[26],E,E,15,N],[10,"mod_sqrt",E,"Performs the modular Square Root operation over a finite…",15,[[[R[2]]]]],[8,"InvSqrt",E,E,N,N],[16,R[26],E,E,16,N],[10,"inv_sqrt",E,"Performs the Inverse Square root of a given value.",16,[[]]],[8,R[67],E,E,N,N],[16,R[26],E,E,17,N],[10,R[46],E,"Using the same trick as in ed25519 decoding, we merge the…",17,[[["self"],[T]]]],[8,R[68],R[27],"Gives the Identity element for the type which it has been…",N,N],[10,R[43],E,"Returns the identity element for the implemented type,…",18,[[],["self"]]],[8,R[69],E,"This trait pretends to be a verification in ct_time about…",N,N],[10,R[44],E,"Checks the point coordinates agains the curve equation to…",19,[[["self"]],[R[2]]]],[11,"from",R[28],E,0,[[[T]],[T]]],[11,R[30],E,E,0,[[["self"]],[T]]],[11,R[31],E,E,0,[[["self"],[T]]]],[11,"into",E,E,0,[[],[U]]],[11,R[32],E,E,0,[[[U]],[R[36]]]],[11,R[33],E,E,0,[[],[R[36]]]],[11,R[34],E,E,0,[[["self"]],[T]]],[11,R[39],E,E,0,[[["self"]],[T]]],[11,R[37],E,E,0,[[["self"]],[R[40]]]],[11,"conditional_negate",E,E,0,[[["self"],[R[2]]]]],[11,"clear",E,E,0,[[["self"]]]],[11,R[38],E,E,0,[[]]],[11,"vzip",E,E,0,[[],["v"]]],[11,"from",R[29],E,1,[[[T]],[T]]],[11,R[30],E,E,1,[[["self"]],[T]]],[11,R[31],E,E,1,[[["self"],[T]]]],[11,"into",E,E,1,[[],[U]]],[11,R[32],E,E,1,[[[U]],[R[36]]]],[11,R[33],E,E,1,[[],[R[36]]]],[11,R[34],E,E,1,[[["self"]],[T]]],[11,R[39],E,E,1,[[["self"]],[T]]],[11,R[37],E,E,1,[[["self"]],[R[40]]]],[11,"vzip",E,E,1,[[],["v"]]],[11,"from",R[35],E,2,[[[T]],[T]]],[11,R[30],E,E,2,[[["self"]],[T]]],[11,R[31],E,E,2,[[["self"],[T]]]],[11,"into",E,E,2,[[],[U]]],[11,R[32],E,E,2,[[[U]],[R[36]]]],[11,R[33],E,E,2,[[],[R[36]]]],[11,R[34],E,E,2,[[["self"]],[T]]],[11,R[39],E,E,2,[[["self"]],[T]]],[11,R[37],E,E,2,[[["self"]],[R[40]]]],[11,"clear",E,E,2,[[["self"]]]],[11,R[38],E,E,2,[[]]],[11,"vzip",E,E,2,[[],["v"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[30],E,E,3,[[["self"]],[T]]],[11,R[31],E,E,3,[[["self"],[T]]]],[11,"into",E,E,3,[[],[U]]],[11,R[32],E,E,3,[[[U]],[R[36]]]],[11,R[33],E,E,3,[[],[R[36]]]],[11,R[34],E,E,3,[[["self"]],[T]]],[11,R[39],E,E,3,[[["self"]],[T]]],[11,R[37],E,E,3,[[["self"]],[R[40]]]],[11,"clear",E,E,3,[[["self"]]]],[11,R[38],E,E,3,[[]]],[11,"vzip",E,E,3,[[],["v"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[30],E,E,4,[[["self"]],[T]]],[11,R[31],E,E,4,[[["self"],[T]]]],[11,"into",E,E,4,[[],[U]]],[11,R[32],E,E,4,[[[U]],[R[36]]]],[11,R[33],E,E,4,[[],[R[36]]]],[11,R[34],E,E,4,[[["self"]],[T]]],[11,R[39],E,E,4,[[["self"]],[T]]],[11,R[37],E,E,4,[[["self"]],[R[40]]]],[11,"clear",E,E,4,[[["self"]]]],[11,R[38],E,E,4,[[]]],[11,"vzip",E,E,4,[[],["v"]]],[11,"from",E,E,5,[[[T]],[T]]],[11,"into",E,E,5,[[],[U]]],[11,R[32],E,E,5,[[[U]],[R[36]]]],[11,R[33],E,E,5,[[],[R[36]]]],[11,R[34],E,E,5,[[["self"]],[T]]],[11,R[39],E,E,5,[[["self"]],[T]]],[11,R[37],E,E,5,[[["self"]],[R[40]]]],[11,"clear",E,E,5,[[["self"]]]],[11,R[38],E,E,5,[[]]],[11,"vzip",E,E,5,[[],["v"]]],[11,"from",R[41],E,7,[[[T]],[T]]],[11,R[30],E,E,7,[[["self"]],[T]]],[11,R[31],E,E,7,[[["self"],[T]]]],[11,"into",E,E,7,[[],[U]]],[11,R[32],E,E,7,[[[U]],[R[36]]]],[11,R[33],E,E,7,[[],[R[36]]]],[11,R[34],E,E,7,[[["self"]],[T]]],[11,R[39],E,E,7,[[["self"]],[T]]],[11,R[37],E,E,7,[[["self"]],[R[40]]]],[11,"clear",E,E,7,[[["self"]]]],[11,R[38],E,E,7,[[]]],[11,"vzip",E,E,7,[[],["v"]]],[11,"from",R[42],E,8,[[[T]],[T]]],[11,R[30],E,E,8,[[["self"]],[T]]],[11,R[31],E,E,8,[[["self"],[T]]]],[11,"into",E,E,8,[[],[U]]],[11,R[32],E,E,8,[[[U]],[R[36]]]],[11,R[33],E,E,8,[[],[R[36]]]],[11,R[34],E,E,8,[[["self"]],[T]]],[11,R[39],E,E,8,[[["self"]],[T]]],[11,R[37],E,E,8,[[["self"]],[R[40]]]],[11,"vzip",E,E,8,[[],["v"]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[30],E,E,9,[[["self"]],[T]]],[11,R[31],E,E,9,[[["self"],[T]]]],[11,"into",E,E,9,[[],[U]]],[11,R[32],E,E,9,[[[U]],[R[36]]]],[11,R[33],E,E,9,[[],[R[36]]]],[11,R[34],E,E,9,[[["self"]],[T]]],[11,R[39],E,E,9,[[["self"]],[T]]],[11,R[37],E,E,9,[[["self"]],[R[40]]]],[11,"clear",E,E,9,[[["self"]]]],[11,R[38],E,E,9,[[]]],[11,"vzip",E,E,9,[[],["v"]]],[11,R[43],R[28],"Returns the Identity element over the finite field modulo…",0,[[],[R[1]]]],[11,R[43],R[29],"Returns the `Identity` element for `Scalar` which equals…",1,[[],[R[3]]]],[11,R[43],R[35],"Returns the `CompressedEdwardsY` identity point value that…",2,[[],[R[14]]]],[11,R[43],E,"Returns the Edwards Point identity value = `(0, 1, 1, 0)`.",3,[[],[R[13]]]],[11,R[43],E,"Returns the Edwards Point identity value = `(0, 1, 1)`.",4,[[],[R[17]]]],[11,R[43],E,"Returns the Edwards Point identity value = `(0, 1)`.",5,[[],[R[48]]]],[11,R[43],R[42],"Returns the Identity point on `CompressedRistretto` format.",8,[[],[R[25]]]],[11,R[43],E,R[53],9,[[],[R[23]]]],[11,R[44],R[35],R[45],3,[[["self"]],[R[2]]]],[11,R[44],E,R[45],4,[[["self"]],[R[2]]]],[11,R[44],E,"Verifies if the curve equation holds given the (X, Y)…",5,[[["self"]],[R[2]]]],[11,R[44],R[42],"A valid `RistrettoPoint` should have exactly order `L`…",9,[[["self"]],[R[2]]]],[11,R[46],R[28],"The first part of the return value signals whether u/v was…",0,[[["self"],[R[1]]]]],[11,"from",E,R[47],0,[[["u8"]],[R[1]]]],[11,"from",E,R[47],0,[[["u16"]],[R[1]]]],[11,"from",E,R[47],0,[[["u32"]],[R[1]]]],[11,"from",E,R[47],0,[[["u64"]],[R[1]]]],[11,"from",E,R[47],0,[[["u128"]],[R[1]]]],[11,"from",E,"Given a Ristretto255Scalar on canonical bytes…",0,[[[R[54]]],[R[1]]]],[11,"from",R[29],R[47],1,[[["u8"]],[R[3]]]],[11,"from",E,R[47],1,[[["u16"]],[R[3]]]],[11,"from",E,R[47],1,[[["u32"]],[R[3]]]],[11,"from",E,R[47],1,[[["u64"]],[R[3]]]],[11,"from",E,R[47],1,[[["u128"]],[R[3]]]],[11,"from",R[35],"Given (X:Y:Z) in ε passing to εε can beperformed in 3M+ 1S…",3,[[[R[17]]],[R[13]]]],[11,"from",E,"In affine form, each elliptic curve point has 2…",3,[[[R[48]]],[R[13]]]],[11,"from",E,"Given (X:Y:T:Z) in εε, passing to ε is cost-free by simply…",4,[[[R[13]]],[R[17]]]],[11,"from",E,"The key idea of projective coordinates is that instead of…",4,[[[R[48]]],[R[17]]]],[11,"from",E,"Given (X:Y:Z:T) in εε, passing to affine can be performed…",5,[[[R[13]]],[R[48]]]],[11,"from",E,"Reduce the point from Projective to Affine coordinates…",5,[[[R[17]]],[R[48]]]],[11,"cmp",R[28],E,0,[[["self"]],[R[49]]]],[11,"cmp",R[29],E,1,[[["self"]],[R[49]]]],[11,R[50],R[28],E,0,[[["self"],[R[1]]],[[R[22],[R[49]]],[R[49]]]]],[11,R[50],R[29],E,1,[[["self"],[R[3]]],[[R[22],[R[49]]],[R[49]]]]],[11,R[51],R[28],"Returns the default value for a FieldElement = Zero.",0,[[],[R[1]]]],[11,R[51],R[35],"Returns the identity for `CompressedEdwardsY` point.",2,[[],[R[14]]]],[11,R[51],E,"Returns the default EdwardsPoint Extended Coordinates: (0,…",3,[[],[R[13]]]],[11,R[51],E,"Returns the default ProjectivePoint Extended Coordinates:…",4,[[],[R[17]]]],[11,R[51],E,"Returns the default Twisted Edwards AffinePoint…",5,[[],[R[48]]]],[11,R[51],R[41],E,7,[[],[R[52]]]],[11,R[51],R[42],R[53],9,[[],[R[23]]]],[11,"into",R[28],"Given a FieldElement reference get it's Ristretto255Scalar…",0,[[],[R[54]]]],[11,"clone",E,E,0,[[["self"]],[R[1]]]],[11,"clone",R[29],E,1,[[["self"]],[R[3]]]],[11,"clone",R[35],E,2,[[["self"]],[R[14]]]],[11,"clone",E,E,3,[[["self"]],[R[13]]]],[11,"clone",E,E,4,[[["self"]],[R[17]]]],[11,"clone",R[41],E,7,[[["self"]],[R[52]]]],[11,"clone",R[42],E,8,[[["self"]],[R[25]]]],[11,"clone",E,E,9,[[["self"]],[R[23]]]],[11,"eq",R[35],E,2,[[["self"],[R[14]]],["bool"]]],[11,"eq",E,E,3,[[["self"],[R[13]]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[17]]],["bool"]]],[11,"eq",E,E,5,[[["self"]],["bool"]]],[11,"eq",R[12],E,6,[[["self"],[R[1]]],["bool"]]],[11,"eq",R[41],E,7,[[["self"],[R[52]]],["bool"]]],[11,"eq",R[42],E,8,[[["self"],[R[25]]],["bool"]]],[11,"eq",E,E,9,[[["self"],[R[23]]],["bool"]]],[11,"eq",R[12],E,10,[[["self"],[R[3]]],["bool"]]],[11,"fmt",R[28],E,0,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",R[29],E,1,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",R[35],E,2,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",E,E,3,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",E,E,4,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",E,E,5,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",R[41],E,7,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",R[42],E,8,[[["self"],[R[55]]],[R[36]]]],[11,"fmt",E,E,9,[[["self"],[R[55]]],[R[36]]]],[11,"sub",R[28],R[56],0,[[[R[1]]],[R[1]]]],[11,"sub",R[29],"Compute `a - b (mod l)`.",1,[[[R[3]]],[R[3]]]],[11,"sub",R[35],"Substract two EdwardsPoints and give the resulting…",3,[[[R[13]]],[R[13]]]],[11,"sub",E,"Add two ProjectivePoints, negating the second one, This…",4,[[[R[17]]],[R[17]]]],[11,"add",R[28],R[56],0,[[[R[1]]],[R[1]]]],[11,"add",R[29],R[56],1,[[[R[3]]],[R[3]]]],[11,"add",R[35],"Add two EdwardsPoints and give the resulting…",3,[[[R[13]]],[R[13]]]],[11,"add",E,"Add two ProjectivePoints and give the resulting…",4,[[[R[17]]],[R[17]]]],[11,"add",R[42],"Performs the addition of two RistrettoPoints following the…",9,[[[R[23]]],[R[23]]]],[11,"mul",R[28],"This Mul implementation returns a double precision result.",0,[[[R[1]]],[R[1]]]],[11,"mul",R[29],"This `Mul` implementation returns a double precision…",1,[[[R[3]]],[R[3]]]],[11,"mul",R[35],R[57],3,[[[R[3]]],[R[13]]]],[11,"mul",E,R[57],4,[[[R[3]]],[R[17]]]],[11,"mul",R[42],R[58],9,[[[R[3]]],[R[23]]]],[11,"mul",R[12],R[58],10,[[[R[23]]],[R[23]]]],[11,"div",R[28],"Performs the op: `x / y (mod l)`.",0,[[[R[1]]],[R[1]]]],[11,"neg",E,"Computes `-self (mod l)`.",0,[[],[R[1]]]],[11,"neg",R[29],"Performs the negate operation over the sub-group modulo l.",1,[[],[R[3]]]],[11,"neg",R[35],"Negates an `CompressedEdwardsY` by decompressing it,…",2,[[],[R[14]]]],[11,"neg",E,"Negates an `EdwardsPoint` giving it as a result",3,[[],[R[13]]]],[11,"neg",E,"Negates an `ProjectivePoint` giving it as a result",4,[[],[R[17]]]],[11,"neg",E,"Negates an `AffinePoint` giving it as a result. Since the…",5,[[],[R[48]]]],[11,"neg",R[42],"Negates a `RistrettoPoint` giving it's negated…",9,[[],[R[23]]]],[11,"index",R[28],E,0,[[["self"],["usize"]],["u64"]]],[11,"index",R[29],E,1,[[["self"],["usize"]],["u64"]]],[11,"index",R[35],E,2,[[["self"],["usize"]],["u8"]]],[11,"index",R[42],E,8,[[["self"],["usize"]],["u8"]]],[11,R[59],R[28],E,0,[[["self"],["usize"]],["u64"]]],[11,R[59],R[29],E,1,[[["self"],["usize"]],["u64"]]],[11,R[59],R[35],E,2,[[["self"],["usize"]],["u8"]]],[11,"ct_eq",E,E,2,[[["self"],[R[14]]],[R[2]]]],[11,"ct_eq",E,E,3,[[["self"],[R[13]]],[R[2]]]],[11,"ct_eq",E,E,4,[[["self"],[R[17]]],[R[2]]]],[11,"ct_eq",E,E,5,[[["self"]],[R[2]]]],[11,"ct_eq",R[12],"Test equality between two `FieldElement`s. Since the…",6,[[["self"],[R[1]]],[R[2]]]],[11,"ct_eq",R[41],E,7,[[["self"],[R[52]]],[R[2]]]],[11,"ct_eq",R[42],E,8,[[["self"]],[R[2]]]],[11,"ct_eq",E,"As specified on the Ristretto protocol docs:…",9,[[["self"],[R[23]]],[R[2]]]],[11,"ct_eq",R[12],"Test equality between two `Scalar`s. Since the internal…",10,[[["self"],[R[3]]],[R[2]]]],[11,"conditional_select",E,E,6,[[["self"],[R[2]]],["self"]]]],"p":[[3,R[19]],[3,"Scalar"],[3,R[60]],[3,R[61]],[3,R[62]],[3,R[63]],[6,R[19]],[3,R[64]],[3,R[65]],[3,R[66]],[6,"Scalar"],[8,"Square"],[8,"Double"],[8,"Half"],[8,"Pow"],[8,"ModSqrt"],[8,"InvSqrt"],[8,R[67]],[8,R[68]],[8,R[69]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);